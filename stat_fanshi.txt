在一个Redux应用中，所有的state都被保存在一个单一的对象中，当应用越复杂的时候，不可避免有一些数据相互引用，建议你尽可能地把 state 范式化，不存在嵌套。把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据。把应用的 state 想像成数据库。下面以一个博客中的文章为例
上面的数据结构比较复杂，并且有部分数据是重复的。这里还存在一些让人关心的问题
* 当数据在多处冗余后，需要更新时，很难保证所有的数据都进行更新。
* 嵌套的数据意味着 reducer 逻辑嵌套更多、复杂度更高。尤其是在打算更新深层嵌套数据时。
* 不可变的数据在更新时需要状态树的祖先数据进行复制和更新，并且新的对象引用会导致与之 connect 的所有 UI 组件都重复 render。尽管要显示的数据没有发生任何改变，对深层嵌套的数据对象进行更新也会强制完全无关的 UI 组件重复 render
正因为如此，在 Redux Store 中管理关系数据或嵌套数据的推荐做法是将这一部分视为数据库，并且将数据按范式化存储。
范式化的数据包含下面几个概念：
* 任何类型的数据在 state 中都有自己的 “表”。
* 任何 “数据表” 应将各个项目存储在对象中，其中每个项目的 ID 作为 key，项目本身作为 value。
* 任何对单个项目的引用都应该根据存储项目的 ID 来完成。
* ID 数组应该用于排序。
设计范式化的 State
范式化的数据包含下面几个概念：
* 任何类型的数据在 state 中都有自己的 “表”。
* 任何 “数据表” 应将各个项目存储在对象中，其中每个项目的 ID 作为 key，项目本身作为 value。
* 任何对单个项目的引用都应该根据存储项目的 ID 来完成。
* ID 数组应该用于排序。
这种 state 在结构上更加扁平。与原始的嵌套形式相比，有下面几个地方的改进：
* 每个数据项只在一个地方定义，如果数据项需要更新的话不用在多处改变
* reducer 逻辑不用处理深层次的嵌套，因此看上去可能会更加简单
* 检索或者更新给定数据项的逻辑变得简单与一致。给定一个数据项的 type 和 ID，不必挖掘其他对象而是通过几个简单的步骤就能查找到它。
* 每个数据类型都是唯一的，像改评论这样的更新仅仅需要状态树中 “comment > byId > comment” 这部分的复制。这也就意味着在 UI 中只有数据发生变化的一部分才会发生更新。与之前的不同的是，之前嵌套形式的结构需要更新整个 comment 对象，post 对象的父级，以及整个 post 对象的数组。这样就会让所有的 Post 组件和 Comment 组件都再次渲染。
需要注意的是，范式化的 state 意味更多的组件被 connect，每个组件负责查找自己的数据，这和小部分的组件被 connect，然后查找大部分的数据再进行向下传递数据是恰恰相反的。事实证明，connect 父组件只需要将数据项的 Id 传递给 connect 的子对象是在 Redux 应用中优化 UI 性能的良好模式，因此保持范式化的 state 在提高性能方面起着关键作用。